/**
 * SpaceTime - A two-row 7-segment LED clock for tracking open hours at VHS.
 *
 * By Bruce Fletcher
 */

#include <stdio.h>
#include <string.h>
#include <avr/interrupt.h>
#include "uart.h"
#include "shift.h"
#include "timer.h"
#include "display.h"
#include "keypad.h"
#include "serial.h"


/**
 * State for the keypad time editing state machine in process_keypress().
 *
 * It lives out here so main() and parse_time() can inspect it.
 */
static enum
{
  EDIT_INACTIVE = 0,
  EDIT_CURRENT_TIME,
  EDIT_CLOSING_TIME
} edit_activity;

static unsigned char edit_position;
static unsigned char edit_value[4];


/**
 * Convert a timestamp into a set of 4 digits to display on one clock row.
 *
 * The timestamp is from timer.c, and the output display structure is
 * used by display.c.
 */
static void prepare_time(display_row_t *display, const timestamp_t *timestamp)
{
  display->digit[0].value = (timestamp->hour > 9 ? timestamp->hour / 10 : DISPLAY_CHAR_SPACE);
  display->digit[1].value = timestamp->hour % 10;
  display->digit[2].value = timestamp->minute / 10;
  display->digit[3].value = timestamp->minute % 10;
}


/**
 * Take the editing state generated by process_keypress() and generate a timestamp.
 *
 * Returns 1 (ok) on success, 0 on nonsensical input.
 */
static char parse_time(timestamp_t *ts, const timer_t *edited_time)
{
  unsigned char value;

  memset(ts, 0, sizeof(timestamp_t));

  if (edit_value[0] != 0xff)
    value = edit_value[0] * 10;
  else
    value = (edited_time->ts.hour/10)*10;

  if (edit_value[1] != 0xff)
    value += edit_value[1];
  else
    value += edited_time->ts.hour%10;

  if (value >= 24)
    return 0;

  ts->hour = value;

  if (edit_value[2] != 0xff)
    value = edit_value[2] * 10;
  else
    value = (edited_time->ts.minute/10)*10;

  if (edit_value[3] != 0xff)
    value += edit_value[3];
  else
    value += edited_time->ts.minute%10;

  if (value >= 60)
    return 0;

  ts->minute = value;

  return 1;
}

/**
 * Handle keypresses on the keypad, primarily for editing current/closing times.
 *
 * This function implements a state machine for editing displayed times.
 *
 * It also allows you to cancel the incessant beeping that occurs when closing
 * time is reached.
 */
static void process_keypress()
{
  unsigned char row, digit, editing_this_row, ok, was_active;
  timestamp_t ts;

  was_active = (edit_activity == EDIT_INACTIVE ? 0 : 1);

  if (keypad.keypress == KEY_CURRENT_TIME || keypad.keypress == KEY_CLOSING_TIME)
  {
    if (keypad.keypress == KEY_CURRENT_TIME)
      edit_activity = EDIT_CURRENT_TIME;
    else
      edit_activity = EDIT_CLOSING_TIME;

    edit_position = 0;
    memset(&edit_value, 0xff, sizeof(edit_value));
  }
  else
  if (edit_activity != EDIT_INACTIVE)
  {
    if (keypad.keypress <= KEY_MAX_DIGIT)
    {
      edit_value[edit_position] = keypad.keypress;
      if (edit_position<3)
        ++edit_position;
    }
    else
    {
      switch(keypad.keypress)
      {
        case KEY_CLEAR:
          edit_activity = EDIT_INACTIVE;
          break;

        case KEY_LEFT:
          if (edit_position > 0)
            --edit_position;
          break;

        case KEY_RIGHT:
          if (edit_position < 3)
            ++edit_position;
          break;

        case KEY_ENTER:
          if (edit_activity == EDIT_CURRENT_TIME)
          {
            ok = parse_time(&ts, &current_time);
            if (ok)
              timer_set(&ts, 0);  // 0 = approximate time, we're not doing drift calculations with it
          }
          else
          {
            ok = parse_time(&ts, &closing_time);
            if (ok)
            {
              memcpy(&closing_time.ts, &ts, sizeof(ts));
              closing_time.is_set = 1;
            }
          }
          edit_activity = EDIT_INACTIVE;
          break;

        default:  // This is only present to surpress compiler warnings,
          break;  // it should never actually be hit.
      }
    }
  }

  for (row=0; row<2; ++row)
  {
    if ((row==0 && edit_activity==EDIT_CURRENT_TIME) ||
        (row==1 && edit_activity==EDIT_CLOSING_TIME)    )
      editing_this_row = 1;
    else
      editing_this_row = 0;

    for (digit=0; digit<4; ++digit)
    {
      if (editing_this_row)
      {
        if (edit_value[digit] != 0xff)
          display_buffer[row].digit[digit].value = edit_value[digit];
      }

      if (editing_this_row && digit==edit_position)
        display_buffer[row].digit[digit].underbar = 1;
      else
        display_buffer[row].digit[digit].underbar = 0;
    }
  }

  if (was_active && edit_activity == EDIT_INACTIVE)
  {
    prepare_time(&display_buffer[0], &current_time.ts);
    prepare_time(&display_buffer[1], &closing_time.ts);
  }

  keypad.is_valid = 0;  // Consume the keypress
}

int main(void)
{
  char minute = -1;

  uart_init();
  shift_init();
  timer_init(0);
  display_init();
  keypad_init();
  serial_init();

  printf("\r\n*** BOOTED ***\r\nSpaceTime, yay!\r\n");

  display_buffer_initialize(display_buffer, DISPLAY_MAX_BRIGHTNESS);

  display_buffer[0].separator = DISPLAY_SEPARATOR_BLINK;
  display_buffer[1].separator = DISPLAY_SEPARATOR_OFF;

  prepare_time(&display_buffer[1], &closing_time.ts);

  sei();  // enable interrupts

  timer_beep(10);

  while(1)
  {
    if (minute != current_time.ts.minute && edit_activity != EDIT_CURRENT_TIME)
    {
      minute = current_time.ts.minute;
      prepare_time(&display_buffer[0], &current_time.ts);
    }

    display_update();

    serial_update();

    if (keypad.is_valid)
    {
      timer_beep(3);

      process_keypress();
    }
  }
}

